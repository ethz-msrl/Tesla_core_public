# Magnetic Navigation Toolbox

mag_manip is a toolbox for remote magnetic navigation applications.  Mag_manip
models the behavior of electromagnetic navigation systems (eMNS), particularly
the relationship between the electrical currents running through electromagnets
and the resulting magnetic field that is generated in the workspace. The toolbox
is implemented in C++11, with extensions to Python.

## Predict Magnetic fields Generated by an eMNS (Forward Models)

A *forward model* calculates the magnetic field vector, or magnetic field
gradient at a given position, given the set of electrical currents that are
running through an eMNS. An eMNS is said to *linear in currents* if the
magnetization of its electromagnets responds linearly to current. This is the
case for air-core electromagnets, or ferromagnetic core electromagnets that are
behaving in their linear region. When electromagnets exhibit strong magnetic
saturation, they are said to be *nonlinear in current*. In such cases, nonlinear
forward models will better capture the behavior of such eMNSs.

### Common Forward Model Interface

All forward models inherit from the the ForwardModel type which provides the
following functions.

```cpp
FieldVec field = model.computeFieldFromCurrents(position, currents);
Gradients5Vec gradients = model.computeGradients5FromCurrents(position, currents);
```

In order to create a forward model at runtime, you can use the
ForwardModelFactory class. For example

```cpp
ForwardModelFactory f;
# This creates a forward model of the MPEM type with calibration file given by filename
ForwardModel::Ptr p_model f.create("mpem", filename);
```

### Linear Interpolation Based Models

The following methods are for systems that are linear in current. According to
the *principle of superposition*, the magnetic field generated by an eMNS
featuring several electromagnets is equivalent to the weighted superposition of
the field generated by individual electromagnets. In that case, it is convenient
to map the fields generated by each electromagnet by while a unit current on
each electromagnet at a time. For Ne electromagnets, there will be Ne vector
fields which are scaled by the electromagnet current and summed up to form the
resulting magnetic field.

Mapping is done by measuring the magnetic field using magnetometers or using FEM
data at a fixed number of positions. Interpolation between the measurements is
used to calculate the field value at an arbitrary position.

#### Regular Grid Methods

These interpolation methods require the measurements to be performed on a
regular grid.

##### Polynomial Hermite Interpolation (vfield)

These methods interpolate values inside a voxel based on the measurements at the
surrounding corners. This method is local, and only the values of the
surrounding voxel contribute to the interpolated voxel. As such it is a
computionnaly cheap method, but less accurate than other global methods. For
trilinear interpolation (order k=1), only continuity at the corners is ensured.
For tricubic (order k=3), continuity of the first derivatives is also ensured at
the corners.  The TricubicScalarField interpolant instead interpolates a
function for the magnetic scalar potential.
The interpolant is constrained such that the field values are equal to the
measurements, that the laplacian is zero, and that the dbx/dy dbx/dz, dby/dz,
and d2bx/dydz derivatives equal their finite difference estimates. The
TricubicScalarPotential method naturally ensures that the interpolated field
is curl-free and that the gradient matrix is symmetric.

The following creates a forward model with that type. The interpolation order is
set to tricubic.

```cpp
ForwardModelLinearVField model;
model.setInterpolationType(InterpolateRegular::Type::TRICUBIC);
model.setCalibrationFile(filename);
```

###### Calibration File Format

Two types of calibration file are supported. The older Daedalus style files
(vfield) files define the magnetic field on a grid at unit in separate text
files for each electromagnet. For example, for the first electromagnet a field
called vfield_00.txt defines the magnetic field corresponding to that
electromagnet. The file contains

```text
N # the number of positions, the same as Nx * Ny * Nz
Nx Ny Nz # the number of voxels in the x, y and z directions respectively
x_min x_max # the minimum and maximum x values of the grid
y_min z_max # the minimum and maximum y values of the grid
z_min z_max # the minimum and maximum z values of the grid
x y z Bx By Bz # the position of the measurement,
# followed by the field measurement vector in Tesla
```

Alternatively, you can use the more modern YAML file format. See [this example](test/vfield_valid.yaml)
for a valid file. The file should contain

```yaml
name: MFG # the name of the eMNS
dim_x: 11 # the number of voxels in the x direction
dim_y: 11
dim_z: 11
max_x: 0.005 # the maximum value of the grid in the x direction
max_y: 0.005
max_z: 0.005
min_x: -0.005
min_y: -0.005
min_z: -0.005
vfields:
    coil_0: # this is the name of the first electromagnet
      data:
        -
        # each line contains a magnetic field measurent vector
        # the order of positions is Z, Y, X where first a
        # plane parallel to Z,Y at x = xmin is processed
```

#### Scattered Grid Methods (RBF)

Radial basis function (RBF) interpolation is another interpolation method that
works on unstructured grids or scattered data.  RBFs are generally *global
methods* and perform better than polynomical interpolation, at an increase in
computational cost. RBF interpolants function with different kernels. The
following kernels are implemented in mag_manip

* Gaussian
* Multiquadric
* Inverse Multiquadric
* Cubic
* Thin plate

When in doubt, you can use the Gaussian kernel. To create a forward model using
RBF, use the following snippet

```cpp
ForwardModelLinearRBF model;
model.setCalibrationFile(cal_file);
```

##### RBF Calibration File Format

See [this file](test/rbf_valid.yaml) for an example of a valid RBF calibration file.

```yaml
name: Dummy
vfields:
  coil_0: # this is the name of the first electromagnets.
          # Electromagnets are sorted by name.
    kernel: gaussian # uses the gaussian kernel
    shape_param: 0.1 # controls the spread between kernel values
    nodes:
        -
            position: # the position of the measurement
            value: # the magnetic field vector measurement
```

The only difficulty in RBF interpolation is selecting a good shape parameter.
This value sets the "spread" of the basis functions. A too small value results
in poor conditioning and therefore a poor interpolation, while a too big value
results in an interpolation error due to poor support. Some propose the
following heuristic: 1/(0.815d) where d is the average distance between
measurements. The best is to set this value by trial and error or using leave
one out cross validation.

##### Thin Plate Spline

Related to RBF interpolation is the thin plate spline interpolator. This
computes an interpolation between measurements that is based on an energy
formulation of a flexible plate passing through the measurements. The same
calibration file format as for RBFs is used. To use thin plate spline
interpolation call the following

```cpp
ForwardModelLinearThinPlateSpline model;
model.setCalibrationFile(cal_file);
```

The thin plate spline does not require a shape parameter. Support is experimental.

### Linear Multipole Electromagnet Model

The multipole electromagnet model (MPEM) is an alternate method. It represents
each electromagnet as a small number of magnetic multipoles. Generally a dipole
formulation is sufficient. The pose and strength of these multipoles is fit to
measurements using least-squares.

The advantage of the MPEM is that is produces physically-consistent field
predictions. Namely, the magnetic fields are ensured to have zero divergence, a
property of all magnetic fields, and zero curl, a property of magnetic fields
when there are not free currents. As such the 3x3 gradient matrix can be more
compactly represented by a 5D vector. Conversion functions between the gradient
matrix and gradients5 vector are provided in
[helpers.h](include/mag_manip/helpers.h). A MPEM model can be created using

```cpp
ForwardModelMPEM model;
model.setCalibrationFile(cal_file);
```

See A. J. Petruska, J. Edelmann, and B. J. Nelson, “Model-Based Calibration for
Magnetic Manipulation,” IEEE Trans. Magn., vol. 53, no. 7, pp. 1–6, 2017.

#### MPEM Calibration File Format

See [this file](test/OctoMag_Calibration.yaml) for an example of a calibration
file. Calibration of a MPEM model can be performed using the separate MPEM
package.

## Saturated Linear Model

For eMNs with larger electromagnets that have saturation, one can apply a
function to the linear models to correct for the saturation of the
electromagnets. Note however that this method still assumes that the
electromagnets can be separated, which is not the case since the principle of
superposition does not apply for systems that are nonlinear in current. It can
be however a significant improvement over using a linear model for such systems
and is easy.

In such cases a saturation function for each electromagnet can be fit from data.
For example, a magnetometer can be placed near the electromagnets and the
currents are sweeped through the electromagnet. From this a nominal saturation
function can be fit from the resulting magnetic fields. The following saturation
functions are implemented

* `a * erf (b* i)` where i is the current,
erf represents the error function, and a, b are fitting parameters
of the saturation function
* `a * x / (|i| + b)`
* `a * atan(b * i)`
* `a * tanh(b * i)`

A linear model can be converted to a saturated correction with the following

```cpp
# this creates the linear model
ForwardModelLinear::Ptr p_lin_model(new ForwardModelMPEM);
# this creates the saturated corrected model
ForwardModelSaturation model;
# You need to assign the linear model to the saturation corrected model
  model.setLinearModel(p_lin_model);\
# You set the calibration file of the linear model
  model.setCalibrationFile(cal_file);
# These are the scalar parameters of the saturation function. They are identical
# for all the electromagnets
Eigen::Vector2d params(16.0, 1 / 16.);
 ector<SaturationFunction*> sat_functions;
for (int i = 0; i < model.getNumCoils(); i++) {
  sat_functions.push_back(new SaturationTanh(params));
}
# this assigns the saturation functions to the model
model.setSaturationFunctions(sat_functions);
```

## Calculate Currents Resulting in a Desired Field (Backward Models)

Backward models reverse the relationship of forward models and are useful in
applications where one wants to control the magnetic field vector. In many
eMNSs, the number of electromagnets is larger than 3, and there are therefore
extra degrees of freedom that are available in addition of full control of the
3D field vector at a position. Systems containing eight electromagnets are more
are required for full control of the 3D field vector and 5D magnetic field
gradient.

### Common Backward Model Interface

All backward models inherit from the the BackwardModel type which provides the
following functions.

```cpp
FieldVec field;
Gradient5Vec gradient;
CurrentsVec currents = model.computeCurrentsFromField(position, field);
CurrentsVec currents = model.computeCurrentsFromFieldGradient5(position, field, gradient);
```

In order to create a backward model at runtime, you can use the
BackwardModelFactory class. For example

```cpp
BackwardModelFactory f;
# This creates a forward model of the MPEM type with calibration file given by filename
BackwardModel::Ptr p_model f.create("mpem", filename);
```

### Linear L2 Mimimizers

For systems that are linear in current, the relationship between the magnetic
field vector and magnetic field gradient and currents can be represented by a
matrix relation b = A * i. The currents i that yield the magnetic field b can be
obtained by solving the latter system. Nevertheless, the system may be
underconstrained, particularly if the number of electromagnets is larger than 3.
In such cases one can find the solution that minimizes the L2 norm of i. This is
particularly interesting because it distributes the currents evenly of the
electromagnets and has a tendency to minimize the power consumption, provided
that the electromagnets are of the same size and have the same resistance. For
linear systems, there is a closed form backward model, by using the
Moore-Penrose pseudo inverse of A.

For each linear forward model described above, there is a corresponding backward
model. For example you can run

```cpp
BackwardModelMPEML2 model;
model.setCalibrationFile(cal_file);
# the desired magnetic field position in m
PositionVec position(0, 0, 0);
# the desired magnetic field vector in T
FieldVec field(30e-3, 0, 0);
# the currents that result in the desired field in A
CurrentsVec currents = model.computeCurrentsFromField(position, field);
```

### Saturated Linear

For systems with the saturation correction, a closed form current can also be
computed. See the following snippet

```cpp
BackwardModelLinearL2::Ptr p_lin_model(new BackwardModelMPEML2);
BackwardModelSaturation model;
model.setLinearModel(std::move(p_lin_model));
model.setCalibrationFile(cal_file);
Eigen::Vector2d params(8.0, 1 / 8.);
vector<SaturationFunction*> sat_functions;
for (int i = 0; i < model.getNumCoils(); i++) {
  sat_functions.push_back(new SaturationTanh(params));
}
model.setSaturationFunctions(sat_functions);

ForwardModelMPEM::Ptr p_f_lin_model(new ForwardModelMPEM);
p_f_lin_model->setCalibrationFile(cal_file);
ForwardModelSaturation f_model;
f_model.setLinearModel(std::move(p_f_lin_model));
f_model.setSaturationFunctions(sat_functions);

PositionVec position = PositionVec::Zero();

FieldVec field(0.01, 0, 0);
Gradient5Vec gradient;
gradient << 0.3, 0, 0, 0, 0;
FieldGradient5Vec field_gradient;
field_gradient << field, gradient;
CurrentsVec currents = model.computeCurrentsFromFieldGradient5(position, field, gradient);
```

### Nonlinear Least-Squares Based Backwards Model

For more general forward models, a closed form backward model generally does not
exist. In such cases one can obtain a backwards relation by solving the relation

min_i || bd - g(i) ||^2

where g(i) represents the forward model. In order to find a solution that
minimizes the L2 norm of the currents, the following minimization can be
regularized as

min_i || bd - g(i) ||^2 + lambda * ||i||^2

It is not always clear how to set lambda. Generally you should strive for a
small value such as 0.01. You can set that param using

```cpp
model.setWeightCurrents(lambda)
```

We use Google's ceres solver to perform the latter optimization. See the
following snippet for an example

```cpp
ForwardModel::UPtr p_forward_model(new ForwardModelMPEM);
p_forward_model->setCalibrationFile(cal_file);
BackwardModelNLS backward_model;
backward_model.setForwardModel(std::move(p_forward_model));
# See the ceres documentation for explanation of these options
ceres::Solver::Options options;
# this will show the minimization progress on the console
options.minimizer_progress_to_stdout = true;
backward_model.setSolverOptions(options);
FieldVec field(20e-3, 0, 0);
PositionVec position(0, 0, 0);
CurrentsVec currents = backward_model.computeCurrentsFromField(position, field);
```

## eMNS Parameters Interface

This holds an interface to hold generic eMNS settings. Have a look
[here](include/mag_manip/emns_parameters.h) to see which parameters are defined.

There are two implementations of the interface

1. Implementation via a YAML file. Keeping a single file for the system that is
   shared by all the nodes is one way to hold the settings.
1. Implementation via the ROS parameter server. The interface will query the
   param server for values of the emns parameters.

## Forces and Torques on Dipole

In magnetic navigation, the generated magnetic fields are used to exert magnetic
wrenches on a magnetically-navigated tool. By representing the embedded magnets
in the tool with dipoles, one can calculate the wrenches delivered to the tool
using the relations in [the following
file](include/mag_manip/dipole_interactions.h)
